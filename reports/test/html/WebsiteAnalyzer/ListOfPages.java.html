<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ListOfPages.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">WebsiteAnalyzer</a> &gt; <a href="index.source.html" class="el_package">WebsiteAnalyzer</a> &gt; <span class="el_source">ListOfPages.java</span></div><h1>ListOfPages.java</h1><pre class="source lang-java linenums">package WebsiteAnalyzer;

/*
 * importing the HashSet package to store Sets of items
 */
import java.util.HashSet;

/*
 * this class is intended to store a list of all the pages that the program has discovered
 * this class will also store functions intended to manipulate the list of pages
 * such as reading, writing, modifiying
 * one instance of thie page list will exist for the entire program
 */
<span class="fc" id="L14">public class ListOfPages {</span>

    /*
     * create an ArrayList that will store the Pages in the listOfPages
     */
<span class="fc" id="L19">    HashSet&lt;SinglePage&gt; List = new HashSet&lt;SinglePage&gt;();</span>


    /**
     * this function will take the relative path of a new page as an input
     * the relative path will be checked against the Set of pages
     * if the relative path is found in the Set, a false will be returned
     * if the relative path is not found in the array, a true will be returned
     * @param relativePath
     * @return false if found, true otherwise
     */
    public Boolean duplicateCheck(String relativePath)
    {
<span class="fc" id="L32">        relativePath = URLToPathMapping.normalizePathSlash(relativePath);</span>

        /*
         * search the Set with the created page
         */
<span class="fc bfc" id="L37" title="All 2 branches covered.">        return !List.contains(new SinglePage(relativePath));</span>
    }


    /**
     * this function will take the attributes of a page as an input
     * will add a new page to the array based on the provided inputs
     * will also do a duplication check to ensure that the provided page is not a duplicate
     * @param relativePath
     * @param numInternalImages
     * @param numExternalImages
     * @param numInternalJavaScripts
     * @param numExternalJavaScripts
     * @param numInternalCascadingStyleSheets
     * @param numExternalCascadingStyleSheets
     * @param numIntraPageLinks
     * @param numIntraSiteLinks
     * @param numExternalLinks
     */
    public void addPage(
        String relativePath, int numInternalImages, int numExternalImages,
        int numInternalJavaScripts, int numExternalJavaScripts,
        int numInternalCascadingStyleSheets, int numExternalCascadingStyleSheets,
        int numIntraPageLinks, int numIntraSiteLinks, int numExternalLinks)
    {
<span class="fc" id="L62">        relativePath = URLToPathMapping.normalizePathSlash(relativePath);</span>

        /*
         * do a duplicate check first
         */
<span class="fc bfc" id="L67" title="All 2 branches covered.">        if (duplicateCheck(relativePath))</span>
        {
            /*
             * verify that the list of pages is still small enough to allow another page
             */
<span class="fc bfc" id="L72" title="All 2 branches covered.">            if (List.size() &lt; Website.maxNumPages)</span>
            {
                /*
                 * create a temporary newPage object
                 */
<span class="fc" id="L77">                SinglePage newPage = new SinglePage();</span>
    
                /*
                 * populate the newPage object with the provided attributes
                 */
<span class="fc" id="L82">                newPage.setRelativePath(relativePath);</span>
<span class="fc" id="L83">                newPage.setnumInternalImages(numInternalImages);</span>
<span class="fc" id="L84">                newPage.setnumExternalImages(numExternalImages);</span>
<span class="fc" id="L85">                newPage.setnumInternalJavaScripts(numInternalJavaScripts);</span>
<span class="fc" id="L86">                newPage.setnumExternalJavaScripts(numExternalJavaScripts);</span>
<span class="fc" id="L87">                newPage.setnumInternalCascadingStyleSheets(numInternalCascadingStyleSheets);</span>
<span class="fc" id="L88">                newPage.setnumExternalCascadingStyleSheets(numExternalCascadingStyleSheets);</span>
<span class="fc" id="L89">                newPage.setnumIntraPageLinks(numIntraPageLinks);</span>
<span class="fc" id="L90">                newPage.setnumIntraSiteLinks(numIntraSiteLinks);</span>
<span class="fc" id="L91">                newPage.setnumExternalLinks(numExternalLinks);</span>
    
                /*
                 * insert the new page into the Set
                 */
<span class="fc" id="L96">                List.add(newPage);</span>
<span class="fc" id="L97">            }</span>
            else
            {
                /*
                 * the page list is too large to be able to accept another page
                 * send an error
                 */
<span class="fc" id="L104">                CLI.throwError(&quot;Too many pages in the list!&quot;);</span>
            }
        }
<span class="fc" id="L107">    }</span>


    /**
     * function to bond a page to a element
     * if you find a page that links to an element, this will tie the element to the page
     * @param pageRelativePath
     * @param elementRelativePath
     * @param elementType
     */
    public void pageLinkToElement(String pageRelativePath, String elementRelativePath, String elementType)
    {
<span class="fc" id="L119">        pageRelativePath = URLToPathMapping.normalizePathSlash(pageRelativePath);</span>
<span class="fc" id="L120">        elementRelativePath = URLToPathMapping.normalizePathSlash(elementRelativePath);</span>
        
        /*
         * only execute the linking process if the page exists
         */
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (List.contains(new SinglePage(pageRelativePath)))</span>
		{
            /*
             * retrieve the specified page from the set
             */
<span class="fc" id="L130">            SinglePage tempPage = searchForPage(pageRelativePath);</span>

            /*
             * check that something was returned
             */
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if (!tempPage.getRelativePath().equals(&quot;&quot;))</span>
            {
                /*
                 * add the page that is linked to the element to the set
                 */
<span class="fc bfc" id="L140" title="All 2 branches covered.">                if (elementType.equals(&quot;Image&quot;))</span>
                {
<span class="fc" id="L142">                    tempPage.referencingImages.add(elementRelativePath);</span>
                }
<span class="fc bfc" id="L144" title="All 2 branches covered.">                else if (elementType.equals(&quot;CSS&quot;))</span>
                {
<span class="fc" id="L146">                    tempPage.referencingCSS.add(elementRelativePath);</span>
                }
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">                else if (elementType.equals(&quot;JS&quot;))</span>
                {
<span class="fc" id="L150">                    tempPage.referencingJS.add(elementRelativePath);</span>
                }

                /*
                 * re-insert the page in the set
                 */
<span class="fc" id="L156">                replacePage(tempPage);</span>
            }
        }
<span class="fc" id="L159">    }</span>


    /**
     * search the set for a specified path, and return the instance of that object
     * @param relativePath
     * @return SinglePage from collection
     */
    public SinglePage searchForPage(String relativePath)
    {
<span class="fc" id="L169">        relativePath = URLToPathMapping.normalizePathSlash(relativePath);</span>
        
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (List.contains(new SinglePage(relativePath)))</span>
		{
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">            for (SinglePage Page : List)</span>
			{
<span class="fc bfc" id="L175" title="All 2 branches covered.">                if (Page.equals(new SinglePage(relativePath)))</span>
				{
<span class="fc" id="L177">                    return Page;</span>
				}
<span class="fc" id="L179">            }</span>
        }

        /*
         * nothing was found, just return an empty page
         */
<span class="fc" id="L185">        return new SinglePage();</span>
    }


    /**
     * replace an item in the set with a new instance of that ojbect
     * @param modifiedPage
     */
    public void replacePage(SinglePage modifiedPage)
    {
        /*
         * remove the old instance of the object
         * raplace the old instance of the object with a new object
         */
<span class="fc" id="L199">        List.remove(modifiedPage);</span>
<span class="fc" id="L200">        List.add(modifiedPage);</span>
<span class="fc" id="L201">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>